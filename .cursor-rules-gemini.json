{
  "general": {
    "style": "O código Go deve seguir o estilo oficial do `go fmt` e `go vet`. Utilize o `gofumpt` para um estilo mais rigoroso. Linhas não devem exceder 120 caracteres. Priorize clareza e simplicidade.",
    "naming": "Nomes de variáveis, funções e tipos devem ser concisos e descritivos, seguindo as convenções de Go (CamelCase para exportados, camelCase para não exportados). Evite abreviações desnecessárias. Interfaces devem ser nomeadas com o sufixo 'er' (ex: 'Reader', 'Service').",
    "error_handling": "Erros devem ser tratados explicitamente, retornando `error` como o último valor de retorno de funções. Utilize `errors.Wrap` ou `fmt.Errorf(\"%w\", ...)` para encapsular erros, adicionando contexto. Evite `panic` para erros recuperáveis. Em endpoints HTTP, erros devem ser mapeados para códigos de status HTTP apropriados e mensagens de erro amigáveis para o cliente, sem expor detalhes internos.",
    "comment_style": "Comentários devem ser usados para explicar o *porquê* de uma decisão de design complexa, e não o *o quê* do código. Comentários de documentação para funções e tipos exportados devem seguir o formato `godoc`. Comentários de linha (`//`) para explicações breves.",
    "testing": "Todos os pacotes com lógica de negócios devem ter testes unitários abrangentes. Use a biblioteca `testify` para asserções e mocks. Testes devem cobrir casos de sucesso, falha e edge cases. Testes de integração devem ser separados e executados com tags de build apropriadas. Utilize `httptest` para testar handlers HTTP.",
    "performance": "Priorize algoritmos eficientes e estruturas de dados apropriadas. Evite alocações desnecessárias em loops. Utilize `sync.Pool` para objetos de alto custo de criação. Profile o código com `pprof` para identificar gargalos de performance.",
    "security": "Sempre valide entradas de usuário usando `go-playground/validator.v10`. Evite SQL Injection usando *prepared statements*. Proteja contra XSS e CSRF. Gerencie segredos com variáveis de ambiente ou soluções de cofre de segredos. Implemente rate limiting e timeouts em endpoints críticos. Garanta que as dependências estejam atualizadas e livres de vulnerabilidades conhecidas.",
    "structure": "Siga a Clean Architecture, separando claramente as preocupações. A dependência deve fluir de fora para dentro (e.g., handlers -> services -> repositories). Use interfaces para desacoplar as camadas e facilitar testes e manutenção. Evite importações cíclicas.",
    "concurrency": "Use goroutines e canais para concorrência segura. Evite o uso de locks globais sempre que possível. Prefira o padrão 'Don't communicate by sharing memory; share memory by communicating.' Utilize `sync.WaitGroup` para esperar por goroutines. Monitore goroutines para evitar vazamentos.",
    "logging": "Utilize `zerolog` ou `logrus` para logging estruturado. Logs devem ser informativos e conter contexto suficiente (ID da requisição, usuário, etc.). Logs devem ser categorizados por nível (DEBUG, INFO, WARN, ERROR, FATAL). Evite logar informações sensíveis."
  },
  "folderRules": {
    "cmd/": "Contém o ponto de entrada principal da aplicação (`main.go`). Deve ser mínimo, responsável apenas por inicializar dependências, carregar configurações e iniciar o servidor. Não deve conter lógica de negócios.",
    "internal/config/": "Armazena a lógica de carregamento e parseamento de configurações. Utilize `Viper` para carregar configurações de arquivos `.env`, variáveis de ambiente, ou outros formatos. As configurações devem ser tipadas e validadas.",
    "internal/handlers/": "Contém os controladores da camada de apresentação (geralmente HTTP). Devem ser responsáveis por receber requisições, validar entradas usando `go-playground/validator.v10`, chamar a camada de serviço e retornar respostas. Não devem conter lógica de negócios complexa, apenas orquestração.",
    "internal/services/": "Contém a lógica de negócios principal da aplicação. Implementa as interfaces definidas na camada de domínio. Deve ser agnóstico a detalhes de infraestrutura. Todas as validações e regras de negócio devem residir aqui.",
    "internal/repositories/": "Contém a lógica de acesso a dados (bancos de dados, APIs externas, etc.). Implementa as interfaces de repositório definidas na camada de domínio. Deve ser responsável por mapear modelos de domínio para modelos de persistência e vice-versa.",
    "pkg/middleware/": "Contém middlewares reutilizáveis para a camada HTTP (e.g., autenticação, autorização, logging de requisição, tratamento de pânico). Devem ser genéricos e não específicos a uma única rota ou handler.",
    "pkg/utils/": "Contém funções utilitárias genéricas que podem ser usadas em qualquer parte do projeto. Evite colocar lógica de negócios aqui. Exemplos incluem funções de ajuda para manipulação de strings, data/hora, ou criptografia.",
    "*_test.go": "Arquivos de teste devem ser colocados ao lado do código que estão testando, no mesmo pacote. Nomes de arquivo devem terminar com `_test.go`. Devem seguir as convenções de teste de Go e utilizar `testify` para asserções e mocks. Testes de integração podem ser colocados em subdiretórios `tests/integration/` ou ter tags de build específicas.",
    "api/openapi/": "Contém as especificações OpenAPI/Swagger para a API. Utilize ferramentas como `swag` para gerar a documentação a partir dos comentários do código, ou mantenha-a manualmente se for o caso. O objetivo é ter uma documentação precisa e atualizada da API.",
    "docs/": "Contém documentação adicional do projeto, como diagramas de arquitetura, decisões de design importantes, instruções de deploy, ou qualquer outra informação relevante que não se encaixe nos comentários do código."
  }
}